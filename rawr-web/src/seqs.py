#!/usr/bin/env python
# -*- coding: utf-8 -*-

import pandas as pd
from Bio import AlignIO

__all__ = [
    "getAlnData", "isIdenticalSeq", "isIdenticalPos",
    "sampleSeqDataToSampleSeqIndexData", "sampleAlnDataToSampleAlnIndexData",
    "trueAlnDataToTrueAlnIndexData", "countPairs", "countColumnPairs"
]


def getAlnData(alnfile):
    """
    Get alignments from alnfile. Turn alignment into panda.DataFrame in lowercase.
    :param alnfile: str, address of alignment.
    :return: pandas.DataFrame, alignment matrix
            row_index: seq id
            column_index: 0 to length of input alignment
            content: a t c g and - of input alignment at each position
    """
    aln = AlignIO.read(alnfile, 'fasta')
    seqlen = len(aln[0].seq)
    alndata = pd.DataFrame(columns=[x for x in range(seqlen)])
    temp=[]
    for s in aln:
        newrow = pd.DataFrame(
            data={x: y
                  for x, y in enumerate(s.seq)}, index=[s.id])
        temp.append(newrow)
    alndata = pd.concat(temp)
    return alndata.apply(lambda x: x.str.lower())


def getIndexData(indexfile):
    import numpy as np
    if indexfile.strip().split(".")[-1] == "index":
        with open(indexfile, 'r') as inf:
            line = inf.readline()
        index = np.array([int(x) for x in line.strip().split(',')])
    elif indexfile.strip().split(".")[-1] == "npy":
        index = np.load(indexfile)

    return index


def isIdenticalSeq(sampledData, sampledAlnData):
    """
    Check the validation of sampled seq and sampled alignment.
    If sampled sequences share the same sequences, both id and seqs, as the sampled alignment return True.
    :param sampledData: sampled sequences from input alignment.
    :param sampledAlnData: sampled alignment from outside file.
    :return: Boolean
        True: sampled sequences match the sampled alignment, both id and sequences.
        False: sampled sequences does not match the sampled alignment.
    """
    if not (sampledData.index == sampledAlnData.index).all():
        print("Sampled sequence id does not match sampled alignment id.")
        return False
    else:
        for i in sampledData.index:
            seq1 = ''.join(sampledData.loc[i]).replace('-', '')
            seq2 = ''.join(sampledAlnData.loc[i]).replace('-', '')
            if seq1 != seq2:
                return False
    return True


def isIdenticalPos(seq, seqpos, aln, alnpos):
    """
    Check the validation of the sampled sequences and its positions and the sampled alignment
    and its correspinding positions of sampled data.
    :param seq: pandas.DataFrame, sampled data from input alignment
    :param seqpos: pandas.DataFrame, sampled data from input alignment with "atcg" replaced
    by the column num of the sampledData.
    :param aln: pandas.DataFrame, sampled alignment generated by aligning the sampled seq.
    :param alnpos: pandas.DataFrame, sampled alignment with "atcg" replaced by the column
    num of the sampledData, NOT THE COLUMN NUM OF sampledAlnData.
    :return: Boolean
        True: if sampled position match the alignment position
        False: if sampled position not match the alignment position
    """
    seqi = 0
    for i in range(len(aln)):
        if aln[i] != '-':
            if [seq[seqi], seqpos[seqi]] != [aln[i], alnpos[i]]:
                print("Here not match", seq[seqi], seqpos[seqi], aln[i],
                      alnpos[i])
                return False
            seqi += 1
    return True


def sampleSeqDataToSampleSeqIndexData(sampleIndex, sampleSeqData):
    """
    Map the sampled sequence to the index of input alignment.
    :param sampleSeqData: pandas.DataFrame. The sampled sequence data, which is a matrix consist of "-" and "atcg".
    This matrix is consist of sampled columns from input alignment.
    :param sampleIndex: list. This list contains the column indexes sampled from input alignment. These columns
    consist of the sampleSeqData.
    :return: sampleSeqIndexData, pandas.DataFrame. This is a matrix consist of "-" and numbers, which represent the
    column indexes of input alignment. The number at each position means, this residue is sampled from the correspond
    column of the original input alignment.
    """

    def maptoinput(x):
        if x != '-':
            return sampleIndex[int(x)]
        return x
    sampleSeqIndexData = sampleSeqData[sampleSeqData == '-'].apply(
        lambda x: x.fillna(x.name))
        #lambda x: x.fillna(str(x.name)).astype('string').infer_objects(copy=False))
    #sampleSeqIndexData = sampleSeqIndexData.applymap(maptoinput)
    sampleSeqIndexData = sampleSeqIndexData.apply(lambda col: col.map(maptoinput))
    return sampleSeqIndexData


def sampleAlnDataToSampleAlnIndexData(sampleIndex, sampleSeqData,
                                      sampleAlnData):
    """
    Map the sampleAlnData to the original input alignment column index.
    :param sampleIndex: list, sampled input alignment column index list.
    :param sampleSeqData: pandas.DataFrame, sampled sequence data with "atcg-" as content.
    :param sampleAlnData: pandas.DataFrame, aligned sampled data with "atcg-" as content.
    :return: sampleAlnIndexData: pandas.DataFrame, each residue is represented by a number, which is the column index of
    the input alignment. This shows where does this residue mapped to the original alignment.
    """
    if not isIdenticalSeq(sampleSeqData, sampleAlnData):
        print('Sampled sequence does not match sampled alignment.')
        return
    sampleSeqIndexData = sampleSeqData[sampleSeqData == '-'].apply(
        lambda x: x.fillna(x.name))
        #lambda x: x.fillna(str(x.name)).astype('string').infer_objects(copy=False))
    sampleAlnIndexData = pd.DataFrame()
    temp = []
    for alnid in sampleAlnData.index:
        idxpointer = 0
        aln = sampleAlnData.loc[alnid]
        seqIndex = [
            x for x in sampleSeqIndexData.loc[alnid].tolist() if x != '-'
        ]
        alnIndex = []
        for i in aln.index:
            if aln.loc[i] != '-':
                alnIndex.append(seqIndex[idxpointer])
                idxpointer += 1
            else:
                alnIndex.append('-')
        # if isIdenticalPos(seq, seqpos, aln, alnpos):
        temp.append(pd.DataFrame(alnIndex).T)
    sampleAlnIndexData = pd.concat(temp).set_axis(sampleAlnData.index)

    def maptoinput(x):
        if x != '-':
            return sampleIndex[int(x)]
        return x

    #sampleAlnIndexData = sampleAlnIndexData.applymap(maptoinput)
    sampleAlnIndexData = sampleAlnIndexData.apply(lambda col: col.map(maptoinput))
    return sampleAlnIndexData


def trueAlnDataToTrueAlnIndexData(trueAlnData, estiAlnData):
    import pandas as pd
    if not isIdenticalSeq(trueAlnData, estiAlnData):
        print('Sampled sequence does not match sampled alignment.')
        return
    estiIndexData = estiAlnData[estiAlnData == '-'].apply(
        lambda x: x.fillna(x.name))
        #lambda x: x.fillna(str(x.name)).astype('string').infer_objects(copy=False))
    trueIndexData = pd.DataFrame()
    for alnid in trueAlnData.index:
        idxpointer = 0
        aln = trueAlnData.loc[alnid]
        estiIndex = [x for x in estiIndexData.loc[alnid].tolist() if x != '-']
        trueIndex = []
        for i in aln.index:
            if aln.loc[i] != '-':
                trueIndex.append(estiIndex[idxpointer])
                idxpointer += 1
            else:
                trueIndex.append('-')
        trueIndex = pd.Series(trueIndex, name=alnid)
        trueIndexData = trueIndexData.append(trueIndex)
    return trueIndexData, estiIndexData


def countPairs(sampleIndexData, seqnum, seqlen):
    # the content of pos need to match the index of alndata
    """
    This function is used to count how many pairs appears in the sampledIndexData.
    The output pair count list has a length of maxPossiblePairsInOneColumn * columnNum.
    :param sampleIndexData: pandas.DataFrame. This is a matrix, with numbers and "-" in it.
    The numbers represent the column index in the original input alignment.
    :param seqnum: int, number of alignment.
    :param seqlen: int, length of alignment.
    :return: pairCount, list, the count of each pair in the sampleIndexData.
    The length of pairCount is maxPossiblePairsInOneColumn * columnNum.
    """
    import itertools
    import numpy as np
    from collections import Counter
    pairInOneCol = int(seqnum * (seqnum - 1) / 2)
    pairCount = [0 for x in range(seqlen * pairInOneCol)]
    idlist = sampleIndexData.index.tolist()  # list of seq id.
    totalpair = list(itertools.combinations(
        idlist, 2))  # all possible pair of id in one column.
    for i in range(sampleIndexData.shape[1]):
        count = Counter(
            sampleIndexData[i]
        )  # count of appeared original input alignment index. eg. {'-': 5, 1537: 5}
        for r in count:
            n = count[r]
            if r != '-' and n > 1:
                ids = sampleIndexData[i][sampleIndexData[i].isin(
                    [r])].index.tolist()  # eg. ['t5', 't9', 't1', 't2', 't3']
                pairs = list(itertools.combinations(ids, 2))
                for p in pairs:
                    pairidx = int(r) * pairInOneCol + totalpair.index(
                        p)  # calculate the pair index based on id pair
                    pairCount[pairidx] += 1
    return np.array(pairCount)


def countColumnPairs(indexData, seqlen):
    """
    Get residue pairs of each column from alignments.
    :param indexData: pandas.DataFrame, alignment with charactors replaced by the column indexes.
    :return: columnPairCount, list, count of pairs in each column.
    """
    from collections import Counter
    n, l = indexData.shape
    columnPairCount = [0 for x in range(seqlen)]
    for i in range(l):
        count = Counter(indexData[i].astype('int32', errors='ignore'))
        for p in count:
            n = count[p]
            if p != '-' and n > 1:
                columnPairCount[int(p)] += n * (n - 1) / 2
    return columnPairCount


#
# def getTruthPair(trueAlnData, alndata):
#     trueAlnPos = sampleAlnDataToSampleAlnIndexData(alndata, trueAlnData)
#     truth = countPairs(trueAlnPos, alndata.shape[0], alndata.shape[1])
#     return truth
